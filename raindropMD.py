import csv
import sys
from pathlib import Path
from typing import List, Dict
from urllib.parse import urlencode, urlparse, parse_qs
import click
import logging
import re
import shutil
from rich.console import Console
from rich.table import Table
from rich.prompt import Prompt
from rich.text import Text
from rich.panel import Panel

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='[%(levelname)s] %(message)s'
)
logger = logging.getLogger(__name__)
console = Console()

class Bookmark:
    """A class representing a Raindrop.io bookmark and its metadata."""
    def __init__(self, id: str, title: str, note: str, excerpt: str, url: str, tags: str, created: str, cover: str, highlights: str, favorite: str):
        self.id = id
        self.title = title or 'Untitled'
        self.note = note
        self.excerpt = excerpt
        self.url = url
        self.tags = tags
        self.created = created
        self.cover = cover
        self.highlights = highlights
        self.favorite = favorite

    def highlights_set(self):
        # Return a set of highlight strings for comparison
        if not self.highlights:
            return set()
        return set([h.strip() for h in self.highlights.split('Highlight:') if h.strip()])

    def to_markdown(self) -> str:
        md_lines = [f"## [{self.title}]({self.url})\n"]
        if self.cover:
            md_lines.append(f"![cover image]({self.cover})\n")
        if self.tags:
            tag_list = [f"#{tag.strip().replace(' ', '_')}" for tag in self.tags.split(',') if tag.strip()]
            md_lines.append(f"**Tags:** {' '.join(tag_list)}\n")
        if self.created:
            md_lines.append(f"**Created:** {self.created}\n")
        if self.favorite and self.favorite.lower() == 'true':
            md_lines.append(f"⭐ **Favorite**\n")
        if self.excerpt:
            md_lines.append(f"\n_Excerpt:_ {self.excerpt}\n")
        if self.note:
            md_lines.append(f"\n_Note:_ {self.note}\n")
        if self.highlights:
            highlight_lines = [h.strip() for h in self.highlights.split('Highlight:') if h.strip()]
            if highlight_lines:
                md_lines.append("\n### Highlights:\n")
                for h in highlight_lines:
                    md_lines.append(f"> {h}\n")
        md_lines.append("\n")
        return ''.join(md_lines)

    @staticmethod
    def from_markdown(md_block: str) -> 'Bookmark':
        # Parse a markdown block for a single bookmark and return a Bookmark object
        # This is a simple parser and assumes the format generated by to_markdown()
        import re
        title_url = re.search(r'## \[(.*?)\]\((.*?)\)', md_block)
        title = title_url.group(1) if title_url else ''
        url = title_url.group(2) if title_url else ''
        cover = ''
        tags = ''
        created = ''
        favorite = ''
        excerpt = ''
        note = ''
        highlights = ''
        lines = md_block.splitlines()
        highlights_list = []
        in_highlights = False
        for line in lines:
            if line.startswith('!['):
                m = re.match(r'!\[.*\]\((.*)\)', line)
                if m:
                    cover = m.group(1)
            elif line.startswith('**Tags:**'):
                tags = line.replace('**Tags:**', '').strip().replace('#', '').replace('_', ' ')
            elif line.startswith('**Created:**'):
                created = line.replace('**Created:**', '').strip()
            elif line.startswith('⭐'):
                favorite = 'true'
            elif line.startswith('_Excerpt:_'):
                excerpt = line.replace('_Excerpt:_', '').strip()
            elif line.startswith('_Note:_'):
                note = line.replace('_Note:_', '').strip()
            elif line.startswith('### Highlights:'):
                in_highlights = True
            elif in_highlights and line.startswith('> '):
                highlights_list.append(line[2:].strip())
            elif in_highlights and not line.startswith('> '):
                in_highlights = False
        if highlights_list:
            highlights = 'Highlight:' + '\nHighlight:'.join(highlights_list)
        return Bookmark('', title, note, excerpt, url, tags, created, cover, highlights, favorite)

def parse_raindrop_csv(csv_path: str) -> List[Bookmark]:
    """Parse Raindrop.io CSV and return a list of Bookmark objects. Handles file and CSV errors."""
    bookmarks = []
    try:
        with open(csv_path, newline='', encoding='utf-8') as csvfile:
            try:
                reader = csv.DictReader(csvfile)
                for row in reader:
                    bookmark = Bookmark(
                        id=row.get('id', ''),
                        title=row.get('title', ''),
                        note=row.get('note', ''),
                        excerpt=row.get('excerpt', ''),
                        url=row.get('url', ''),
                        tags=row.get('tags', ''),
                        created=row.get('created', ''),
                        cover=row.get('cover', ''),
                        highlights=row.get('highlights', ''),
                        favorite=row.get('favorite', ''),
                    )
                    bookmarks.append(bookmark)
            except csv.Error as e:
                console.print(Panel(f"Failed to parse CSV file: [bold red]{csv_path}[/bold red]\n[red]{e}[/red]", title="[bold red]CSV Parse Error[/bold red]", style="red"))
                console.print("[yellow]Please check the CSV format and try again.[/yellow]")
                sys.exit(1)
    except FileNotFoundError:
        console.print(Panel(f"File not found: [bold red]{csv_path}[/bold red]", title="[bold red]File Not Found[/bold red]", style="red"))
        console.print("[yellow]Please check the path and try again.[/yellow]")
        sys.exit(1)
    except Exception as e:
        console.print(Panel(f"Unexpected error opening file: [bold red]{csv_path}[/bold red]\n[red]{e}[/red]", title="[bold red]File Error[/bold red]", style="red"))
        sys.exit(1)
    return bookmarks

def parse_markdown_file(md_path: str) -> List[Bookmark]:
    """Parse an existing markdown file into a list of Bookmark objects."""
    if not Path(md_path).is_file():
        console.print(Panel(f"Markdown file not found: [bold red]{md_path}[/bold red]", title="[bold red]File Not Found[/bold red]", style="red"))
        console.print("[yellow]Please check the path and try again.[/yellow]")
        return []
    try:
        with open(md_path, 'r', encoding='utf-8') as f:
            content = f.read()
    except Exception as e:
        console.print(Panel(f"Could not read markdown file: [bold red]{md_path}[/bold red]\n[red]{e}[/red]", title="[bold red]File Read Error[/bold red]", style="red"))
        return []
    # Split by '## [' which starts each bookmark, but keep the delimiter
    import re
    blocks = re.split(r'(?=^## \[)', content, flags=re.MULTILINE)
    bookmarks = []
    for block in blocks:
        if block.strip().startswith('## ['):
            try:
                bm = Bookmark.from_markdown(block)
                # Only add if title and url are both present (valid bookmark)
                if bm.title and bm.url:
                    bookmarks.append(bm)
                else:
                    console.print(Panel(f"Skipped malformed bookmark block: missing title or url.", title="[yellow]Warning[/yellow]", style="yellow"))
            except Exception as e:
                console.print(Panel(f"Failed to parse a bookmark block:\n[red]{e}[/red]", title="[yellow]Warning[/yellow]", style="yellow"))
    return bookmarks

def bookmarks_to_markdown(bookmarks: List[Bookmark]) -> str:
    """Convert a list of Bookmark objects to markdown format."""
    md_lines = ["# Raindrop.io Bookmarks\n"]
    for bm in bookmarks:
        try:
            md_lines.append(bm.to_markdown())
        except Exception as e:
            console.print(Panel(f"Error processing bookmark:\n[red]{e}[/red]", title="[yellow]Warning[/yellow]", style="yellow"))
            continue
    return ''.join(md_lines)

def write_markdown(md_content: str, md_path: str):
    """Write markdown content to file (create or update). Handles file write errors."""
    try:
        with open(md_path, 'w', encoding='utf-8') as mdfile:
            mdfile.write(md_content)
    except Exception as e:
        console.print(Panel(f"Failed to write markdown file: [bold red]{md_path}[/bold red]\n[red]{e}[/red]", title="[bold red]File Write Error[/bold red]", style="red"))
        sys.exit(1)

def list_bookmark_files(bookmark_dir: Path):
    if not bookmark_dir.exists() or not bookmark_dir.is_dir():
        console.print(Panel(f"Directory not found: [bold red]{bookmark_dir}[/bold red]", title="[red]Error[/red]", style="red"))
        return []
    files = sorted([f for f in bookmark_dir.iterdir() if f.suffix == ".md" and f.is_file()])
    if not files:
        console.print(Panel(f"No markdown files found in directory: [bold yellow]{bookmark_dir}[/bold yellow]", title="[yellow]Warning[/yellow]", style="yellow"))
    return files

def print_bookmarks_from_dir(bookmark_dir: Path):
    files = list_bookmark_files(bookmark_dir)
    if not files:
        console.print(f"[bold red]No bookmark files found in {bookmark_dir}.[/bold red]")
        return
    table = Table(title=f"Bookmarks in {bookmark_dir}")
    table.add_column("No.", style="cyan", width=4)
    table.add_column("Title", style="bold")
    table.add_column("Tags", style="magenta")
    table.add_column("Created", style="green")
    table.add_column("Favorite", style="yellow", justify="center")
    for i, f in enumerate(files, 1):
        with open(f, 'r', encoding='utf-8') as md:
            content = md.read()
        title = re.search(r'## \[(.*?)\]', content)
        title = title.group(1) if title else f.name
        tags = re.search(r'\*\*Tags:\*\* (.*)', content)
        tags = tags.group(1) if tags else ''
        created = re.search(r'\*\*Created:\*\* (.*)', content)
        created = created.group(1) if created else ''
        favorite = "⭐" if "⭐" in content else ""
        table.add_row(str(i), title, tags, created, favorite)
    console.print(table)

def remove_bookmark_interactive_dir(bookmark_dir: Path):
    files = list_bookmark_files(bookmark_dir)
    if not files:
        console.print(Panel("No bookmark files found in [bold yellow]{}[/bold yellow].".format(bookmark_dir), title="[red]Error[/red]", style="red"))
        return
    console.print(Panel("Select a bookmark to remove:", title="[bold]Remove Bookmark[/bold]", style="yellow"))
    for i, f in enumerate(files, 1):
        with open(f, 'r', encoding='utf-8') as md:
            title = re.search(r'## \\[(.*?)\\]', md.read())
            title = title.group(1) if title else f.name
        console.print(f"[cyan]{i}.[/cyan] {title} ([dim]{f.name}[/dim])")
    try:
        choice = Prompt.ask("Enter the number to remove (0 to cancel)", default="0")
        choice = int(choice)
        if choice < 1 or choice > len(files):
            console.print(Panel("Cancelled or invalid selection.", title="[yellow]Cancelled[/yellow]", style="yellow"))
            return
        to_remove = files[choice-1]
        to_remove.unlink()
        console.print(Panel(f"Removed bookmark file: [bold green]{to_remove.name}[/bold green]", title="[green]Success[/green]", style="green"))
    except Exception as e:
        console.print(Panel(f"Invalid input or error: {e}", title="[red]Error[/red]", style="red"))

def edit_bookmark_interactive_dir(bookmark_dir: Path):
    files = list_bookmark_files(bookmark_dir)
    if not files:
        console.print(f"[bold red]No bookmark files found in {bookmark_dir}.[/bold red]")
        return
    table = Table(title="Select a bookmark to edit", show_lines=True)
    table.add_column("No.", style="cyan", width=4)
    table.add_column("Title", style="bold")
    table.add_column("File", style="dim")
    for i, f in enumerate(files, 1):
        with open(f, 'r', encoding='utf-8') as md:
            content = md.read()
        title = re.search(r'## \[(.*?)\]', content)
        title = title.group(1) if title else f.name
        table.add_row(str(i), title, f.name)
    console.print(table)
    try:
        choice = Prompt.ask("Enter the number to edit (0 to cancel)", default="0")
        choice = int(choice)
        if choice < 1 or choice > len(files):
            console.print("[yellow]Cancelled or invalid selection.[/yellow]")
            return
        fpath = files[choice-1]
        with open(fpath, 'r', encoding='utf-8') as f:
            content = f.read()
        bm = Bookmark.from_markdown(content)
        # Show preview before editing
        console.print(Panel.fit(content, title=f"Editing: {bm.title}", subtitle=f"File: {fpath.name}"))
        bm.title = Prompt.ask(f"Title", default=bm.title)
        bm.note = Prompt.ask(f"Note", default=bm.note)
        bm.excerpt = Prompt.ask(f"Excerpt", default=bm.excerpt)
        bm.tags = Prompt.ask(f"Tags (comma separated)", default=bm.tags)
        bm.created = Prompt.ask(f"Created", default=bm.created)
        bm.cover = Prompt.ask(f"Cover URL", default=bm.cover)
        bm.highlights = Prompt.ask(f"Highlights (use 'Highlight:' as separator)", default=bm.highlights)
        bm.favorite = Prompt.ask(f"Favorite (true/false)", default=bm.favorite)
        with open(fpath, 'w', encoding='utf-8') as f:
            f.write(bm.to_markdown())
        console.print(f"[green]Updated bookmark:[/green] {bm.title} ({bm.url})")
    except Exception as e:
        console.print(f"[red]Invalid input or error: {e}[/red]")

def fuzzy_search_bookmarks_dir(bookmark_dir: Path, query: str):
    files = list_bookmark_files(bookmark_dir)
    if not files:
        console.print(f"[bold red]No bookmark files found in {bookmark_dir}.[/bold red]")
        return
    from difflib import SequenceMatcher
    query_lower = query.lower()
    results = []
    for f in files:
        with open(f, 'r', encoding='utf-8') as md:
            content = md.read()
        bm = Bookmark.from_markdown(content)
        fields = [bm.title, bm.url, bm.tags, bm.created, bm.favorite, bm.note, bm.highlights]
        def match_score(text):
            if not text:
                return 0
            text = str(text).lower()
            return SequenceMatcher(None, query_lower, text).ratio()
        score = max(match_score(fld) for fld in fields)
        if score > 0.3 or any(query_lower in str(fld).lower() for fld in fields if fld):
            results.append((score, bm, f.name, content))
    results.sort(reverse=True, key=lambda x: x[0])
    if not results:
        console.print(f"[yellow]No bookmarks matched the query: '{query}'[/yellow]")
        return
    table = Table(title=f"Search Results for '{query}'", show_lines=True)
    table.add_column("No.", style="cyan", width=4)
    table.add_column("Title", style="bold")
    table.add_column("Tags", style="magenta")
    table.add_column("Created", style="green")
    table.add_column("Favorite", style="yellow", justify="center")
    table.add_column("File", style="dim")
    for i, (score, bm, fname, content) in enumerate(results, 1):
        # Highlight query in title
        title_text = Text(bm.title)
        if query_lower in bm.title.lower():
            start = bm.title.lower().index(query_lower)
            title_text.stylize("bold red", start, start+len(query))
        tags = bm.tags
        created = bm.created
        favorite = "⭐" if bm.favorite and bm.favorite.lower() == 'true' else ""
        table.add_row(str(i), title_text, tags, created, favorite, fname)
    console.print(table)
    # Preview the first result
    if results:
        score, bm, fname, content = results[0]
        console.print(Panel.fit(content, title=f"Preview: {bm.title}", subtitle=f"File: {fname}"))

def sanitize_title(title: str) -> str:
    # Remove non-alphanumeric characters, replace spaces with underscores, and truncate
    sanitized = re.sub(r'[^\w\- ]', '', title).strip().replace(' ', '_')
    return sanitized[:40] or 'Untitled'

def zettelkasten_filename(bookmark: Bookmark) -> str:
    # Use created date/time if available, else fallback to now
    from datetime import datetime
    try:
        dt = datetime.strptime(bookmark.created, '%Y-%m-%d')
        # If no time, use 00:00
        dt = dt.replace(hour=0, minute=0)
    except Exception:
        dt = datetime.now()
    return f"{dt.strftime('%Y%m%d%H%M')}_{sanitize_title(bookmark.title)}.md"

def write_bookmarks_to_dir(bookmarks: List[Bookmark], out_dir: Path):
    if not out_dir.exists():
        try:
            out_dir.mkdir(parents=True)
            console.print(Panel(f"Created output directory: [bold green]{out_dir}[/bold green]", title="[green]Success[/green]", style="green"))
        except Exception as e:
            console.print(Panel(f"Failed to create output directory: {e}", title="[red]Error[/red]", style="red"))
            sys.exit(1)
    for bm in bookmarks:
        try:
            filename = zettelkasten_filename(bm)
            file_path = out_dir / filename
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(bm.to_markdown())
        except Exception as e:
            console.print(Panel(f"Failed to write bookmark '{getattr(bm, 'title', 'Unknown')}' to file: {e}", title="[red]Error[/red]", style="red"))

def create_or_update_markdown(csv_path: str, out_dir: Path):
    """Parse CSV and write each bookmark to a separate markdown file in out_dir."""
    csv_bookmarks = parse_raindrop_csv(csv_path)
    if not csv_bookmarks:
        console.print(Panel("No bookmarks found in the CSV file.", title="[red]Error[/red]", style="red"))
        sys.exit(1)
    write_bookmarks_to_dir(csv_bookmarks, out_dir)
    console.print(Panel(f"Bookmark files created/updated in: [bold green]{out_dir}[/bold green]", title="[green]Success[/green]", style="green"))

@click.group()
def cli():
    """Raindrop.io CSV to Markdown CLI (zettelkasten mode)"""
    pass

@cli.command()
@click.argument('csv_file', type=click.Path(exists=True))
@click.argument('output_dir', type=click.Path())
def create(csv_file, output_dir):
    """Parse CSV_FILE and create/update one markdown file per bookmark in OUTPUT_DIR."""
    out_dir = Path(output_dir)
    create_or_update_markdown(csv_file, out_dir)

@cli.command('list')
@click.argument('bookmark_dir', type=click.Path(exists=True, file_okay=False))
def list(bookmark_dir):
    """Display all bookmarks in BOOKMARK_DIR."""
    print_bookmarks_from_dir(Path(bookmark_dir))

@cli.command('remove')
@click.argument('bookmark_dir', type=click.Path(exists=True, file_okay=False))
def remove(bookmark_dir):
    """Interactively remove a bookmark file from BOOKMARK_DIR."""
    remove_bookmark_interactive_dir(Path(bookmark_dir))

@cli.command('edit')
@click.argument('bookmark_dir', type=click.Path(exists=True, file_okay=False))
def edit(bookmark_dir):
    """Interactively edit a bookmark file in BOOKMARK_DIR."""
    edit_bookmark_interactive_dir(Path(bookmark_dir))

@cli.command('search')
@click.argument('bookmark_dir', type=click.Path(exists=True, file_okay=False))
@click.argument('query', type=str)
def search(bookmark_dir, query):
    """Fuzzy search bookmarks in BOOKMARK_DIR by QUERY."""
    fuzzy_search_bookmarks_dir(Path(bookmark_dir), query)

if __name__ == "__main__":
    cli()
