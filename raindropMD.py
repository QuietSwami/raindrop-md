import csv
import sys
from pathlib import Path
from typing import List, Dict
from urllib.parse import urlencode, urlparse, parse_qs
import click
import logging
import re
import shutil

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='[%(levelname)s] %(message)s'
)
logger = logging.getLogger(__name__)

class Bookmark:
    """A class representing a Raindrop.io bookmark and its metadata."""
    def __init__(self, id: str, title: str, note: str, excerpt: str, url: str, tags: str, created: str, cover: str, highlights: str, favorite: str):
        self.id = id
        self.title = title or 'Untitled'
        self.note = note
        self.excerpt = excerpt
        self.url = url
        self.tags = tags
        self.created = created
        self.cover = cover
        self.highlights = highlights
        self.favorite = favorite

    def highlights_set(self):
        # Return a set of highlight strings for comparison
        if not self.highlights:
            return set()
        return set([h.strip() for h in self.highlights.split('Highlight:') if h.strip()])

    def to_markdown(self) -> str:
        md_lines = [f"## [{self.title}]({self.url})\n"]
        if self.cover:
            md_lines.append(f"![cover image]({self.cover})\n")
        if self.tags:
            tag_list = [f"#{tag.strip().replace(' ', '_')}" for tag in self.tags.split(',') if tag.strip()]
            md_lines.append(f"**Tags:** {' '.join(tag_list)}\n")
        if self.created:
            md_lines.append(f"**Created:** {self.created}\n")
        if self.favorite and self.favorite.lower() == 'true':
            md_lines.append(f"⭐ **Favorite**\n")
        if self.excerpt:
            md_lines.append(f"\n_Excerpt:_ {self.excerpt}\n")
        if self.note:
            md_lines.append(f"\n_Note:_ {self.note}\n")
        if self.highlights:
            highlight_lines = [h.strip() for h in self.highlights.split('Highlight:') if h.strip()]
            if highlight_lines:
                md_lines.append("\n### Highlights:\n")
                for h in highlight_lines:
                    md_lines.append(f"> {h}\n")
        md_lines.append("\n")
        return ''.join(md_lines)

    @staticmethod
    def from_markdown(md_block: str) -> 'Bookmark':
        # Parse a markdown block for a single bookmark and return a Bookmark object
        # This is a simple parser and assumes the format generated by to_markdown()
        import re
        title_url = re.search(r'## \[(.*?)\]\((.*?)\)', md_block)
        title = title_url.group(1) if title_url else ''
        url = title_url.group(2) if title_url else ''
        cover = ''
        tags = ''
        created = ''
        favorite = ''
        excerpt = ''
        note = ''
        highlights = ''
        lines = md_block.splitlines()
        highlights_list = []
        in_highlights = False
        for line in lines:
            if line.startswith('!['):
                m = re.match(r'!\[.*\]\((.*)\)', line)
                if m:
                    cover = m.group(1)
            elif line.startswith('**Tags:**'):
                tags = line.replace('**Tags:**', '').strip().replace('#', '').replace('_', ' ')
            elif line.startswith('**Created:**'):
                created = line.replace('**Created:**', '').strip()
            elif line.startswith('⭐'):
                favorite = 'true'
            elif line.startswith('_Excerpt:_'):
                excerpt = line.replace('_Excerpt:_', '').strip()
            elif line.startswith('_Note:_'):
                note = line.replace('_Note:_', '').strip()
            elif line.startswith('### Highlights:'):
                in_highlights = True
            elif in_highlights and line.startswith('> '):
                highlights_list.append(line[2:].strip())
            elif in_highlights and not line.startswith('> '):
                in_highlights = False
        if highlights_list:
            highlights = 'Highlight:' + '\nHighlight:'.join(highlights_list)
        return Bookmark('', title, note, excerpt, url, tags, created, cover, highlights, favorite)

def parse_raindrop_csv(csv_path: str) -> List[Bookmark]:
    """Parse Raindrop.io CSV and return a list of Bookmark objects. Handles file and CSV errors."""
    bookmarks = []
    try:
        with open(csv_path, newline='', encoding='utf-8') as csvfile:
            try:
                reader = csv.DictReader(csvfile)
                for row in reader:
                    bookmark = Bookmark(
                        id=row.get('id', ''),
                        title=row.get('title', ''),
                        note=row.get('note', ''),
                        excerpt=row.get('excerpt', ''),
                        url=row.get('url', ''),
                        tags=row.get('tags', ''),
                        created=row.get('created', ''),
                        cover=row.get('cover', ''),
                        highlights=row.get('highlights', ''),
                        favorite=row.get('favorite', ''),
                    )
                    bookmarks.append(bookmark)
            except csv.Error as e:
                logger.error(f"Failed to parse CSV file '{csv_path}': {e}")
                sys.exit(1)
    except FileNotFoundError:
        logger.error(f"File not found: '{csv_path}'. Please check the path and try again.")
        sys.exit(1)
    except Exception as e:
        logger.error(f"Unexpected error opening file '{csv_path}': {e}")
        sys.exit(1)
    return bookmarks

def parse_markdown_file(md_path: str) -> List[Bookmark]:
    """Parse an existing markdown file into a list of Bookmark objects."""
    if not Path(md_path).is_file():
        logger.error(f"Markdown file not found: '{md_path}'. Please check the path and try again.")
        return []
    try:
        with open(md_path, 'r', encoding='utf-8') as f:
            content = f.read()
    except Exception as e:
        logger.error(f"Could not read markdown file '{md_path}': {e}")
        return []
    # Split by '## [' which starts each bookmark, but keep the delimiter
    import re
    blocks = re.split(r'(?=^## \[)', content, flags=re.MULTILINE)
    bookmarks = []
    for block in blocks:
        if block.strip().startswith('## ['):
            try:
                bm = Bookmark.from_markdown(block)
                # Only add if title and url are both present (valid bookmark)
                if bm.title and bm.url:
                    bookmarks.append(bm)
                else:
                    logger.warning(f"Skipped malformed bookmark block: missing title or url.")
            except Exception as e:
                logger.warning(f"Failed to parse a bookmark block: {e}")
    return bookmarks

def bookmarks_to_markdown(bookmarks: List[Bookmark]) -> str:
    """Convert a list of Bookmark objects to markdown format."""
    md_lines = ["# Raindrop.io Bookmarks\n"]
    for bm in bookmarks:
        try:
            md_lines.append(bm.to_markdown())
        except Exception as e:
            logger.error(f"Error processing bookmark: {e}")
            continue
    return ''.join(md_lines)

def write_markdown(md_content: str, md_path: str):
    """Write markdown content to file (create or update). Handles file write errors."""
    try:
        with open(md_path, 'w', encoding='utf-8') as mdfile:
            mdfile.write(md_content)
    except Exception as e:
        logger.error(f"Failed to write markdown file '{md_path}': {e}")
        sys.exit(1)

def list_bookmark_files(bookmark_dir: Path):
    return sorted([f for f in bookmark_dir.glob('*.md') if f.is_file()])

def print_bookmarks_from_dir(bookmark_dir: Path):
    files = list_bookmark_files(bookmark_dir)
    if not files:
        print(f"No bookmark files found in {bookmark_dir}.")
        return
    print(f"Found {len(files)} bookmarks in {bookmark_dir}:")
    for i, f in enumerate(files, 1):
        with open(f, 'r', encoding='utf-8') as md:
            title = re.search(r'## \[(.*?)\]', md.read())
            title = title.group(1) if title else f.name
        print(f"{i}. {title} ({f.name})")

def remove_bookmark_interactive_dir(bookmark_dir: Path):
    files = list_bookmark_files(bookmark_dir)
    if not files:
        print(f"No bookmark files found in {bookmark_dir}.")
        return
    print(f"Select a bookmark to remove:")
    for i, f in enumerate(files, 1):
        with open(f, 'r', encoding='utf-8') as md:
            title = re.search(r'## \[(.*?)\]', md.read())
            title = title.group(1) if title else f.name
        print(f"{i}. {title} ({f.name})")
    try:
        choice = int(input("Enter the number to remove (0 to cancel): "))
        if choice < 1 or choice > len(files):
            print("Cancelled or invalid selection.")
            return
        to_remove = files[choice-1]
        to_remove.unlink()
        print(f"Removed bookmark file: {to_remove.name}")
    except Exception:
        print("Invalid input.")

def edit_bookmark_interactive_dir(bookmark_dir: Path):
    files = list_bookmark_files(bookmark_dir)
    if not files:
        print(f"No bookmark files found in {bookmark_dir}.")
        return
    print(f"Select a bookmark to edit:")
    for i, f in enumerate(files, 1):
        with open(f, 'r', encoding='utf-8') as md:
            title = re.search(r'## \[(.*?)\]', md.read())
            title = title.group(1) if title else f.name
        print(f"{i}. {title} ({f.name})")
    try:
        choice = int(input("Enter the number to edit (0 to cancel): "))
        if choice < 1 or choice > len(files):
            print("Cancelled or invalid selection.")
            return
        fpath = files[choice-1]
        with open(fpath, 'r', encoding='utf-8') as f:
            content = f.read()
        bm = Bookmark.from_markdown(content)
        print(f"Editing bookmark: {bm.title} ({bm.url})")
        bm.title = input(f"Title [{bm.title}]: ") or bm.title
        bm.note = input(f"Note [{bm.note}]: ") or bm.note
        bm.excerpt = input(f"Excerpt [{bm.excerpt}]: ") or bm.excerpt
        bm.tags = input(f"Tags (comma separated) [{bm.tags}]: ") or bm.tags
        bm.created = input(f"Created [{bm.created}]: ") or bm.created
        bm.cover = input(f"Cover URL [{bm.cover}]: ") or bm.cover
        bm.highlights = input(f"Highlights (use 'Highlight:' as separator) [{bm.highlights}]: ") or bm.highlights
        bm.favorite = input(f"Favorite (true/false) [{bm.favorite}]: ") or bm.favorite
        with open(fpath, 'w', encoding='utf-8') as f:
            f.write(bm.to_markdown())
        print(f"Updated bookmark: {bm.title} ({bm.url})")
    except Exception:
        print("Invalid input.")

def fuzzy_search_bookmarks_dir(bookmark_dir: Path, query: str):
    files = list_bookmark_files(bookmark_dir)
    if not files:
        print(f"No bookmark files found in {bookmark_dir}.")
        return
    from difflib import SequenceMatcher
    query = query.lower()
    results = []
    for f in files:
        with open(f, 'r', encoding='utf-8') as md:
            content = md.read()
        bm = Bookmark.from_markdown(content)
        fields = [bm.title, bm.url, bm.tags, bm.created, bm.favorite, bm.note, bm.highlights]
        def match_score(text):
            if not text:
                return 0
            text = str(text).lower()
            return SequenceMatcher(None, query, text).ratio()
        score = max(match_score(fld) for fld in fields)
        if score > 0.3 or any(query in str(fld).lower() for fld in fields if fld):
            results.append((score, bm, f.name))
    results.sort(reverse=True, key=lambda x: x[0])
    if not results:
        print(f"No bookmarks matched the query: '{query}'")
        return
    print(f"Found {len(results)} matching bookmarks:")
    for i, (score, bm, fname) in enumerate(results, 1):
        print(f"{i}. {bm.title} ({bm.url}) [{fname}] [score: {score:.2f}]")

def sanitize_title(title: str) -> str:
    # Remove non-alphanumeric characters, replace spaces with underscores, and truncate
    sanitized = re.sub(r'[^\w\- ]', '', title).strip().replace(' ', '_')
    return sanitized[:40] or 'Untitled'

def zettelkasten_filename(bookmark: Bookmark) -> str:
    # Use created date/time if available, else fallback to now
    from datetime import datetime
    try:
        dt = datetime.strptime(bookmark.created, '%Y-%m-%d')
        # If no time, use 00:00
        dt = dt.replace(hour=0, minute=0)
    except Exception:
        dt = datetime.now()
    return f"{dt.strftime('%Y%m%d%H%M')}_{sanitize_title(bookmark.title)}.md"

def write_bookmarks_to_dir(bookmarks: List[Bookmark], out_dir: Path):
    out_dir.mkdir(parents=True, exist_ok=True)
    for bm in bookmarks:
        fname = zettelkasten_filename(bm)
        fpath = out_dir / fname
        with open(fpath, 'w', encoding='utf-8') as f:
            f.write(bm.to_markdown())
    logger.info(f"Wrote {len(bookmarks)} bookmarks to {out_dir}")

def create_or_update_markdown(csv_path: str, out_dir: Path):
    """Parse CSV and write each bookmark to a separate markdown file in out_dir."""
    csv_bookmarks = parse_raindrop_csv(csv_path)
    if not csv_bookmarks:
        print("No bookmarks found in the CSV file.")
        sys.exit(1)
    write_bookmarks_to_dir(csv_bookmarks, out_dir)
    print(f"Bookmark files created/updated in: {out_dir}")

@click.group()
def cli():
    """Raindrop.io CSV to Markdown CLI (zettelkasten mode)"""
    pass

@cli.command()
@click.argument('csv_file', type=click.Path(exists=True))
@click.argument('output_dir', type=click.Path())
def create(csv_file, output_dir):
    """Parse CSV_FILE and create/update one markdown file per bookmark in OUTPUT_DIR."""
    out_dir = Path(output_dir)
    create_or_update_markdown(csv_file, out_dir)

@cli.command('list')
@click.argument('bookmark_dir', type=click.Path(exists=True, file_okay=False))
def list(bookmark_dir):
    """Display all bookmarks in BOOKMARK_DIR."""
    print_bookmarks_from_dir(Path(bookmark_dir))

@cli.command('remove')
@click.argument('bookmark_dir', type=click.Path(exists=True, file_okay=False))
def remove(bookmark_dir):
    """Interactively remove a bookmark file from BOOKMARK_DIR."""
    remove_bookmark_interactive_dir(Path(bookmark_dir))

@cli.command('edit')
@click.argument('bookmark_dir', type=click.Path(exists=True, file_okay=False))
def edit(bookmark_dir):
    """Interactively edit a bookmark file in BOOKMARK_DIR."""
    edit_bookmark_interactive_dir(Path(bookmark_dir))

@cli.command('search')
@click.argument('bookmark_dir', type=click.Path(exists=True, file_okay=False))
@click.argument('query', type=str)
def search(bookmark_dir, query):
    """Fuzzy search bookmarks in BOOKMARK_DIR by QUERY."""
    fuzzy_search_bookmarks_dir(Path(bookmark_dir), query)

if __name__ == "__main__":
    cli()
